# Игровое поле
maps = [1,2,3,
        4,5,6,
        7,8,9]

maps_copy = [1,2,3,
        4,5,6,
        7,8,9] # это нужно для обработки случаев когда пытаются сделать ход на поле, которое уже занято
# основной список поле maps мы изменяем, поэтому могут быть сбои в поиске индекса элемента при повторном вводе этого элемента пользователем(тк он уже вводил цифра поля уже заменилась на крест или ноль)

# список корректных ходов для проверки верности введенных данных
correct_moves = [1,2,3,4,5,6,7,8,9]

correct_flag = False # Флаг для проверки корректности ввода. Пока он не станет True запрос на корректный ввод не прекратится


# Список победных победных линий
victories = [[0,1,2],
             [3,4,5],
             [6,7,8],
             [0,3,6],
             [1,4,7],
             [2,5,8],
             [0,4,8],
             [2,4,6]]
 
# Вывод карты на экран
def print_maps():
    print(maps[0], end = " ")
    print(maps[1], end = " ")
    print(maps[2])
 
    print(maps[3], end = " ")
    print(maps[4], end = " ")
    print(maps[5])
 
    print(maps[6], end = " ")
    print(maps[7], end = " ")
    print(maps[8])    
 
# Совершение хода
def move_maps(move, symbol):
    ind = maps_copy.index(move) # получаем индекс поля, в которое игрок походил
    maps[ind] = symbol # заменяем цифру по этому индексу на символ игрока, который походил
 
# Получаем текущий результат игры и проверяем не выиграл ли один из игроков
# Переберем все победные линии из списка victories и проверим нет ли там комбинации из трех крестиков или трех ноликов
def get_result():
    win = ""
 
    for i in victories:
        if maps[i[0]] == "X" and maps[i[1]] == "X" and maps[i[2]] == "X":
            win = "X" # проверка игрока кресты. Мы проверяем не соответствует ли текущее положение крестов одной из победных линий
        elif maps[i[0]] == "O" and maps[i[1]] == "O" and maps[i[2]] == "O":
            win = "O" # проверка игрока нули
        else: # проверка на ничью
            check = "" # создаем строку в которую перенесу все символы из карты чтобы проверить заполнились ли все поля нулями и единичками
            # цикл по списку maps. Каждый элемент прибавляем к строке сheck предварительно переведя его в тип str(строка)
            for i in maps:
                check += str(i)
            if check.isalpha() == True: # проверим строку все ли в ней буквы Х и О. Ноль обозначается буквой о латинской на поле.
                # check.isalpha() вернет True когда строка полностью состоит из латинских букв. если вернулось True и ни одно условие выше не выполнилось, то значит все ячейки заполнены никто не выиграл и поэтому надо вернуть ничью
                win = "Ничья"
            
    return win
    
# Основная программа
# Вводим флаг окончания игры. Когда game_over примет значение True, тогда игровой цикл завершится
game_over = False

# Флаг, отвечающий за то, кто начнет игру. После одного раунда меняется на False и начинает игрок №2
now_is_moving_symbol = "X"

name1 = input("Игрок 1, введите свое имя: ")
name2 = input("Игрок 2, введите свое имя: ")

# Основной игровой цикл длится пока game_over False. Выход после победы одного из игроков
 
while game_over == False:
    # Показываем карту

    print_maps()
    # Запрашиваем у играющего куда делать ход
    while correct_flag != True: # цикл ввода хода одного игрока пока не будет введен корректный номер
        if now_is_moving_symbol == "X":
            symbol = "X"
            move = input(name1 + ", ваш ход: ")
        else:
            symbol = "O"
            move = input(name2 + ", ваш ход: ")
        if move.isdigit() == True and int(move) in correct_moves and (maps[int(move) - 1] != "X" and maps[int(move) - 1] != "O"): # Проверяем методом для строк move.isdigit() на то состоит ли строка из чисел. Если это условие выполнилось, то проверяем есть ли введенное числов в списке корректных(123456789)
            # если введут строку из цифр и букв isdigit выдаст False. True nлько когда вся строка состоит из цифр
            # третье условие в скобках проверяет стоит ли там уже крест или ноль. Тк у нас поле от 1 до 9, а индексы каждой клетки смещенгы на один от move надо отнять единицу чтобы получить индекс поля которое мы хотим проверить на наличие там крестика или нолика.
            correct_flag = True # ход верный
    
        else:
            print("Некорректный ввод, попробуйте еще раз.") # В остальных случаях выводим ошибку
    move = int(move)
    
    move_maps(move, symbol) # делаем ход в указанную ячейку

    correct_flag = False # обнуляем корректность хода
    
    win = get_result() # определим победителя
    if win != "":
        game_over = True
    else:
        game_over = False
    
    if now_is_moving_symbol == "X":
        now_is_moving_symbol = "O"
    elif now_is_moving_symbol == "O":
        now_is_moving_symbol = "X"
        # меняем игровой символ игрока 1 и 2
    
# Игра окончена. Покажем карту. Объявим победителя.        
print_maps()

if win == "Ничья":
    print(win)
else:
    print("Победили", win)
